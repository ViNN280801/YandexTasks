// Нам даны 3 времени продажи билетов:
// 1. 1 человек
// 2. 2 человека
// 3. 3 человека
// нам нужно найти минимальное время, которое потребуется кассиру, чтобы продать билеты
// для каждого человека

// Используя флоучарт с https://algo.monster/flowchart, так как нам говорят найти
// минимальное время, которое потребуется кассиру, чтобы продать билеты
// то цепочка такая:
// Нужно ли найти оптимальное значение? Да — нужно минимизировать общее время обслуживания.
// 2. Есть ли перекрывающиеся подзадачи? Да — выбор для группы из i человек зависит от того,
//    как были обслужены предыдущие i−1,i−2,i−3
//    -> значит можно использовать динамическое программирование
// 3. Можно ли применить жадный алгоритм?
//    Нет — нельзя жадно просто выбирать лучшее локальное объединение,
//    потому что может возникнуть ситуация, где на более раннем шаге объединение даёт проигрыш в будущем.

// Итого:
// 1. Нужно минимизировать общее время обслуживания.
// 2. Есть перекрывающиеся подзадачи.
// 3. Нельзя применить жадный алгоритм.

// Пусть dp[i] - минимальное время, которое потребуется кассиру, чтобы продать билеты для i человек
// Обозначим тогда:
// A[i] - время продажи билета для 1 человека, начиная с i-го
// B[i] - время продажи билета для 2 человек, начиная с i-го
// C[i] - время продажи билета для 3 человек, начиная с i-го

// Тогда:
// dp[i] = min(dp[i-1] + A[i-1],
//             dp[i-2] + B[i-2], // если i-2 >= 0
//             dp[i-3] + C[i-3]) // если i-3 >= 0

#include <iostream>
#include <limits>
#include <vector>

int main()
{
    // n - количество человек
    int n;
    std::cin >> n;

    // Если нет людей, то и времени не нужно
    if (n <= 0)
    {
        std::cout << 0 << std::endl;
        return EXIT_SUCCESS;
    }

    // A[i] - время продажи билета для 1 человека, начиная с i-го
    // B[i] - время продажи билета для 2 человек, начиная с i-го
    // C[i] - время продажи билета для 3 человек, начиная с i-го
    std::vector<int> A(n);
    std::vector<int> B(n);
    std::vector<int> C(n);

    for (int i = 0; i < n; i++)
        std::cin >> A[i] >> B[i] >> C[i];

    if (n == 1)
    {
        std::cout << A[0] << std::endl;
        return EXIT_SUCCESS;
    }

    if (n == 2)
    {
        std::cout << std::min(A[0] + A[1], B[0]) << std::endl;
        return EXIT_SUCCESS;
    }

    // Заполняем вектор dp максимальными значениями для int, так как мы будем искать минимум
    // +1, так как для 0 людей нужно 0 времени, следовательно dp[0] = 0
    std::vector<int> dp(n + 1, std::numeric_limits<int>::max());
    dp[0] = 0;

    // Чтобы вычислить dp[i], нужно знать dp[i-1], dp[i-2], dp[i-3]
    // Поэтому начинаем с 1, так как для 0 людей нужно 0 времени
    // Сложность: O(n), так как мы проходим по всем i 1 раз
    for (int i = 1; i <= n; i++)
    {
        dp[i] = std::min(dp[i], dp[i - 1] + A[i - 1]);
        if (i >= 2)
            dp[i] = std::min(dp[i], dp[i - 2] + B[i - 2]);
        if (i >= 3)
            dp[i] = std::min(dp[i], dp[i - 3] + C[i - 3]);
    }

    std::cout << dp[n] << std::endl;
    return EXIT_SUCCESS;
}
